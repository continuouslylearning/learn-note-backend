const express = require('express');
const Resource = require('../models/resource');
const Topic = require('../models/topic');
const { requiredFields } = require('./validation/common');
const { validateResource, appendResourceType } = require('./validation/resource');

const router = express.Router();

router.get('/', (req, res, next) => {
  const userId = req.user.id;
  // Configure ?orderBy
  const shouldOrderByColumn = req.query.orderBy || false;
  // Configure ?orderDirection
  const orderDirection = req.query.orderDirection || 'desc';
  // Configure ?limit
  const limit = req.query.limit;

  Topic.query()
    .select(
      'resources.id as id',
      'resources.parent as parent',
      'resources.title as title',
      'resources.type as type',
      'resources.uri as uri',
      'resources.completed as completed',
      'resources.lastOpened as lastOpened',
      'topics.title as topicTitle'
    )
    .join('resources', 'topics.id', 'resources.parent')
    .where({ 'topics.userId': userId })
    .modify(query => {
      if (shouldOrderByColumn) query.orderBy(shouldOrderByColumn, orderDirection);
      if (limit) query.limit(limit);
      return query;
    })
    .then(results => {
      results.forEach(result => {
        result.parent = {
          id: result.parent,
          title: result.topicTitle
        };
        delete result.topicTitle;
      });
      // results.sort((a, b) => new Date(b.lastOpened) - new Date(a.lastOpened));
      return res.json(results);
    })
    .catch(next);
});

router.get('/:id', (req, res, next) => {
  const userId = req.user.id;
  const id = req.params.id;

  return Resource.query()
    .select(
      'resources.id as id',
      'resources.parent as parentId',
      'resources.title as title',
      'resources.type as type',
      'resources.uri as uri',
      'resources.completed as completed',
      'resources.lastOpened as lastOpened',
      'topics.title as parentTitle'
    )
    .from('resources')
    .leftJoin('topics', 'resources.parent', 'topics.id')
    .where({ 'resources.userId': userId, 'resources.id': id })
    .then(([resource]) => {
      if (!resource) return Promise.reject();
      // Normalize parent to an object
      resource.parent = { id: resource.parentId, title: resource.parentTitle };
      delete resource.parentId, delete resource.parentTitle;
      return res.json(resource);
    })
    .catch(next);
});

router.put('/:id', validateResource, async (req, res, next) => {
  const userId = req.user.id;
  const resourceId = req.params.id;

  const updateableFields = ['title', 'completed', 'lastOpened'];
  const updatedResource = {};

  updateableFields.forEach(field => {
    if (field in req.body) {
      updatedResource[field] = req.body[field];
    }
  });

  try {
    let resource = await Resource.query()
      .where({ userId, id: resourceId })
      .first();

    if(!resource) {
      return next();
    }

    const parentTopicId = resource.parent;

    if('title' in updatedResource){
      const titleExists = await Resource.query()
        .where({ 
          userId, 
          parent: parentTopicId,
          title: req.body.title,  
        })
        .whereNot({ id: resourceId })
        .first();

      if(titleExists){
        const err = new Error('Resource with this title already exists');
        err.status = 400;
        throw err;
      }
    }

    resource = await Resource.query()
      .update(updatedResource)
      .where({ userId, id: resourceId })
      .returning('*')
      .first();

    delete resource.userId;

    if (resource.parent !== null) {
      resource.parent = await Topic.query()
        .select('id', 'title')
        .where({ id: resource.parent })
        .first();
    }

    return res.status(201).json(resource);
  } catch(e) {
    return next(e);
  }
});

router.post('/', requiredFields(['title', 'parent', 'uri']), validateResource, appendResourceType, (req, res, next) => {
  const userId = req.user.id;

  // NOTE: type is generated by middleware, but it is NOT updatable by consumers
  let { parent, title, uri, type } = req.body;

  Resource.query()
    .where({ userId, title })
    .first()
    .then(resource => {
      if (resource) {
        const err = new Error('Resource with this title already exists');
        err.status = 400;
        return Promise.reject(err);
      }

      return Resource.query()
        .insert({ userId, parent, title, uri, type })
        .returning('*');
    })
    .then(resource => {
      delete resource.userId;
      return res.status(201).json(resource);
    })
    .catch(next);
});

router.delete('/:id', (req, res, next) => {
  const resourceId = req.params.id;
  const userId = req.user.id;

  Resource.query()
    .delete()
    .where({ userId, id: resourceId })
    .returning('*')
    .first()
    .then(resource => {
      if (!resource) {
        return Promise.reject();
      }
      return res.sendStatus(204);
    })
    .catch(next);
});

module.exports = router;
