const express = require('express');
const Resource = require('../models/resource');
const Topic = require('../models/topic');
const { requiredFields } = require('./validation/common');
const {
  validateResource,
  appendResourceType
} = require('./validation/resource');

const router = express.Router();

router.get('/', async (req, res, next) => {
  const userId = req.user.id;
  // Configure ?orderBy
  const shouldOrderByColumn = req.query.orderBy || false;
  // Configure ?orderDirection
  const orderDirection = req.query.orderDirection || 'desc';
  // Configure ?limit
  const limit = req.query.limit;

  try {
    let resources = await Resource.query()
      .select(
        'resources.id as id',
        'resources.parent as parentId',
        'resources.title as title',
        'resources.type as type',
        'resources.uri as uri',
        'resources.completed as completed',
        'resources.lastOpened as lastOpened',
        'topics.title as parentTitle'
      )
      .join('topics', 'topics.id', 'resources.parent')
      .where({ 'topics.userId': userId })
      .modify(query => {
        if (shouldOrderByColumn)
          query.orderBy(shouldOrderByColumn, orderDirection);
        if (limit) query.limit(limit);
        return query;
      });

    resources = resources.map(resource => resource.normalize());
    return res.json(resources);
  } catch(e){
    next(e);
  }
});

router.get('/:id', async (req, res, next) => {
  const userId = req.user.id;
  const id = req.params.id;

  try {
    // Update lastOpened every time resource is accessed
    await Resource.query()
      .update({ lastOpened: new Date().toISOString() })
      .where({ userId, id });

    const resource = await Resource.query()
      .select(
        'resources.id as id',
        'resources.parent as parentId',
        'resources.title as title',
        'resources.type as type',
        'resources.uri as uri',
        'resources.completed as completed',
        'resources.lastOpened as lastOpened',
        'topics.title as parentTitle'
      )
      .from('resources')
      .leftJoin('topics', 'resources.parent', 'topics.id')
      .where({ 'resources.userId': userId, 'resources.id': id })
      .first();

    if (!resource) throw { 
      message: 'Resource not found.', 
      status: 404 
    };
    // Normalize parent to an object
    return res.json(resource.normalize());
  } catch (err) {
    return next(err);
  }
});

router.put('/:id', validateResource, async (req, res, next) => {
  const userId = req.user.id;
  const resourceId = req.params.id;

  const updateableFields = ['title', 'completed', 'lastOpened'];
  const updatedResource = {};

  updateableFields.forEach(field => {
    if (field in req.body) {
      updatedResource[field] = req.body[field];
    }
  });

  try {
    let resource = await Resource.query()
      .where({ userId, id: resourceId })
      .first();

    if (!resource) {
      return next();
    }

    const parentTopicId = resource.parent;

    if ('title' in updatedResource) {
      const resourceWithSameName = await Resource.query()
        .where({
          userId,
          parent: parentTopicId,
          title: req.body.title
        })
        .whereNot({ id: resourceId })
        .first();

      if (resourceWithSameName) {
        throw {
          message: 'Resource with this title already exists',
          status: 400
        };
      }
    }

    resource = await Resource.query()
      .update(updatedResource)
      .where({ userId, id: resourceId })
      .returning('*')
      .first();

    delete resource.userId;

    if (resource.parent !== null) {
      resource.parent = await Topic.query()
        .select('id', 'title')
        .where({ id: resource.parent })
        .first();
    }

    return res.status(201).json(resource);
  } catch (e) {
    return next(e);
  }
});

router.post(
  '/',
  requiredFields(['title', 'parent', 'uri']),
  validateResource,
  appendResourceType,
  async (req, res, next) => {
    const userId = req.user.id;

    // NOTE: type is generated by middleware, but it is NOT updatable by consumers
    let { parent, title, uri, type } = req.body;

    try {
      const resourceWithSameName = await Resource.query()
        .where({ userId, title, parent })
        .first();
      
      if (resourceWithSameName) {
        throw {
          message: 'Resource with this title already exists',
          status: 400
        };
      }

      const resource = await Resource.query()
        .insert({ 
          userId, 
          parent, 
          title, 
          uri, 
          type 
        })
        .returning('*');
    
      delete resource.userId;

      return res.status(201).json(resource);
    } catch(e){
      next(e);
    }
  }
);

router.delete('/:id', async (req, res, next) => {
  const resourceId = req.params.id;
  const userId = req.user.id;

  try {
    const resource = await Resource.query()
      .delete()
      .where({ userId, id: resourceId })
      .returning('*')
      .first();
    
    if (!resource) {
      return next();
    }
    return res.sendStatus(204);
  } catch(e){
    next(e);
  }
});

module.exports = router;
